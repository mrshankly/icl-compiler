PARSER_BEGIN(Parser)

public class Parser {

  public static void main(String args[]) {
    Parser parser = new Parser(System.in);
    ASTNode expression;
    IValue value;

    while (true) {
      try {
        expression = parser.Start();
        value = expression.eval();
        System.out.println(value.show());
      } catch (ParseException e) {
        e.printStackTrace();
        parser.ReInit(System.in);
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  < ASSIGN : "=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < TIMES : "*" >
| < DIV : "/" >
| < GT : ">" >
| < LT : "<" >
| < GTE : ">=" >
| < LTE : "<=" >
| < OR : "||" >
| < AND : "&&" >
| < NOT : "~" >
| < LPAR : "(" >
| < RPAR : ")" >
| < EL : ";;" >
| < NUM : (["0"-"9"])+ >
| < TRUE : "true" >
| < FALSE : "false" >
| < ID : ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","_","0"-"9"])* >
}

ASTNode Start() :
{
  ASTNode t;
}
{
  t = LogicalOR() <EL>
  { return t; }
}

ASTNode LogicalOR() :
{
  ASTNode t1, t2;
}
{
  t1=LogicalAND()
  ( <OR> t2=LogicalAND()
    { t1 = new ASTOr(t1, t2); }
  )*
  { return t1; }
}

ASTNode LogicalAND() :
{
  ASTNode t1, t2;
}
{
  t1=Comparison()
  ( <AND> t2=Comparison()
    { t1 = new ASTAnd(t1, t2); }
  )*
  { return t1; }
}

ASTNode Comparison() :
{
  Token op;
  ASTNode t1, t2;
}
{
  t1=Expression()
  ( (op=<GT> | op=<LT> | op=<GTE> | op=<LTE>) t2=Expression()
    {
      if (op.kind == GT) {
        t1 = new ASTGreaterThan(t1, t2);
      } else if (op.kind == LT) {
        t1 = new ASTLessThan(t1, t2);
      } else if (op.kind == GTE) {
        t1 = new ASTGreaterThanEqual(t1, t2);
      } else {
        t1 = new ASTLessThanEqual(t1, t2);
      }
    }
  )?
  { return t1; }
}

ASTNode Expression() :
{
  Token op;
  ASTNode t1, t2;
}
{
  t1=Term()
  ( (op=<PLUS> | op=<MINUS>) t2=Term()
    {
      if (op.kind == PLUS) {
        t1 = new ASTAdd(t1, t2);
      } else {
        t1 = new ASTSub(t1, t2);
      }
    }
  )*
  { return t1; }
}

ASTNode Term() :
{
  Token op;
  ASTNode t1, t2;
}
{
  t1=Unary()
  ( (op=<TIMES> | op=<DIV>) t2=Unary()
    {
      if (op.kind == TIMES) {
        t1 = new ASTMul(t1, t2);
      } else {
        t1 = new ASTDiv(t1, t2);
      }
    }
  )*
  { return t1; }
}

ASTNode Unary() :
{
  ASTNode t1;
}
{
  (
    t1=Factor()
  |
    <MINUS> t1=Unary()
    { t1 = new ASTNegate(t1); }
  |
    <NOT> t1=Unary()
    { t1 = new ASTNot(t1); }
  )
  { return t1; }
}

ASTNode Factor() :
{
  Token n;
  ASTNode t1, t2;
}
{
  (
    n=<NUM>
    { t1 = new ASTNum(Integer.parseInt(n.image)); }
  |
    (n=<TRUE> | n=<FALSE>)
    { t1 = new ASTBool(Boolean.parseBoolean(n.image)); }
  |
    <LPAR> t1=LogicalOR() <RPAR>
  )
  { return t1; }
}
