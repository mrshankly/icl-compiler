PARSER_BEGIN(Parser)

import java.util.List;
import java.util.ArrayList;
import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class Parser {

  public static void main(String args[]) {
    
    Parser parser;
    ASTNode expression;
    IValue value;
    
    if (args.length == 0){
      parser = new Parser(System.in);
      while (true) {
        try {
          expression = parser.Start();
          value = expression.eval(new Environment());
          System.out.println(value.show());
        } catch (ParseException e) {
          e.printStackTrace();
          parser.ReInit(System.in);
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    } else if(args.length == 1){
      try {
        parser = new Parser(new FileInputStream(args[0]));
      } catch(FileNotFoundException e){
        System.out.printf("File '%s' not found.\n",args[0]);
        return;
      }
      
      try {
          expression = parser.Start();
          value = expression.eval(new Environment());
          System.out.println(value.show());
        } catch (ParseException e) {
          e.printStackTrace();
        } catch (Exception e) {
          e.printStackTrace();
        }
    }else{
      System.out.println("Usage: java Parser [<inout_file>]");
    }
      
    
    

    
  }
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  < IF : "if" >
| < THEN : "then" >
| < ELSE : "else" >
| < NEW : "new" >
| < WHILE : "while" >
| < DO : "do" >
| < LET : "let" >
| < IN : "in" >
| < FUN : "fun" >
| < ARROW : "->" >
| < END : "end" >
| < ASSIGN : "=" >
| < ASSIGNREF : ":=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < TIMES : "*" >
| < DIV : "/" >
| < GT : ">" >
| < LT : "<" >
| < GTE : ">=" >
| < LTE : "<=" >
| < EQ : "==" >
| < NEQ : "~=" >
| < OR : "||" >
| < AND : "&&" >
| < NOT : "~" >
| < LPAR : "(" >
| < RPAR : ")" >
| < COMMA : "," >
| < SEQ : ";" >
| < DEREF : "!" >
| < EL : ";;" >
| < NUM : (["0"-"9"])+ >
| < TRUE : "true" >
| < FALSE : "false" >
| < ID : ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","_","0"-"9"])* >
}

ASTNode Start() :
{
  ASTNode t;
}
{
  t = Expression() <EL>
  { return t; }
}

ASTNode Expression() :
{
  ASTNode t1, t2;
}
{
  t1=Assignment()
  ( <SEQ> t2=Assignment()
    { t1 = new ASTSeq(t1, t2); }
  )*
  { return t1; }
}

ASTNode Assignment() :
{
  ASTNode t1, t2;
}
{
  t1=LogicalOR()
  ( <ASSIGNREF> t2=LogicalOR()
    { t1 = new ASTAssign(t1, t2); }
  )?
  { return t1; }
}

ASTNode LogicalOR() :
{
  ASTNode t1, t2;
}
{
  t1=LogicalAND()
  ( <OR> t2=LogicalAND()
    { t1 = new ASTOr(t1, t2); }
  )*
  { return t1; }
}

ASTNode LogicalAND() :
{
  ASTNode t1, t2;
}
{
  t1=Equality()
  ( <AND> t2=Equality()
    { t1 = new ASTAnd(t1, t2); }
  )*
  { return t1; }
}

ASTNode Equality() :
{
  Token op;
  ASTNode t1, t2;
}
{
  t1=Comparison()
  ( (op=<EQ> | op=<NEQ>) t2=Comparison()
    {
      if (op.kind == EQ) {
        t1 = new ASTEquals(t1, t2);
      } else {
        t1 = new ASTNotEquals(t1, t2);
      }
    }
  )?
  { return t1; }
}

ASTNode Comparison() :
{
  Token op;
  ASTNode t1, t2;
}
{
  t1=AddSub()
  ( (op=<GT> | op=<LT> | op=<GTE> | op=<LTE>) t2=AddSub()
    {
      if (op.kind == GT) {
        t1 = new ASTGreaterThan(t1, t2);
      } else if (op.kind == LT) {
        t1 = new ASTLessThan(t1, t2);
      } else if (op.kind == GTE) {
        t1 = new ASTGreaterThanEqual(t1, t2);
      } else {
        t1 = new ASTLessThanEqual(t1, t2);
      }
    }
  )?
  { return t1; }
}

ASTNode AddSub() :
{
  Token op;
  ASTNode t1, t2;
}
{
  t1=Term()
  ( (op=<PLUS> | op=<MINUS>) t2=Term()
    {
      if (op.kind == PLUS) {
        t1 = new ASTAdd(t1, t2);
      } else {
        t1 = new ASTSub(t1, t2);
      }
    }
  )*
  { return t1; }
}

ASTNode Term() :
{
  Token op;
  ASTNode t1, t2;
}
{
  t1=Unary()
  ( (op=<TIMES> | op=<DIV>) t2=Unary()
    {
      if (op.kind == TIMES) {
        t1 = new ASTMul(t1, t2);
      } else {
        t1 = new ASTDiv(t1, t2);
      }
    }
  )*
  { return t1; }
}

ASTNode Unary() :
{
  ASTNode t1;
}
{
  (
    t1=FunctionCall()
  |
    <MINUS> t1=Unary()
    { t1 = new ASTNegate(t1); }
  |
    <NOT> t1=Unary()
    { t1 = new ASTNot(t1); }
  |
    <DEREF> t1=Unary()
    { t1 = new ASTDeRef(t1); }
  |
    <NEW> t1=Unary()
    { t1 = new ASTNew(t1); }
  )
  { return t1; }
}

ASTNode FunctionCall() :
{
  ASTNode t1, t2;
  List<ASTNode> args = new ArrayList<ASTNode>();
}
{
  t1=Factor()
  (
    <LPAR>
    (
      t2=Expression() { args.add(t2); }
      (
        <COMMA> t2=Expression()
        { args.add(t2); }
      )*
    )?
    <RPAR>
    { t1 = new ASTApply(t1, args); }
  )?
  { return t1; }
}

ASTNode Factor() :
{
  Token n;
  ASTNode t1, t2, t3;
  List<String> ids = new ArrayList<String>();
  List<ASTNode> init_exprs = new ArrayList<ASTNode>();
}
{
  (
    n=<ID>
    { t1 = new ASTId(n.image); }
  |
    n=<NUM>
    { t1 = new ASTNum(Integer.parseInt(n.image)); }
  |
    (n=<TRUE> | n=<FALSE>)
    { t1 = new ASTBool(Boolean.parseBoolean(n.image)); }
  |
    <IF> t1=Expression() <THEN> t2=Expression() <ELSE> t3=Expression() <END>
    { t1 = new ASTIf(t1, t2, t3); }
  |
    <WHILE> t1=Expression() <DO> t2=Expression() <END>
    { t1 = new ASTWhile(t1, t2); }
  |
    <LET>
    ( n=<ID> <ASSIGN> t1=Expression()
      {
        ids.add(n.image);
        init_exprs.add(t1);
      }
    )+
    <IN> t2=Expression() <END>
    { t1 = new ASTLet(ids, init_exprs, t2); }
  |
    <FUN>
    (
      n=<ID> { ids.add(n.image); }
      (
        <COMMA> n=<ID>
        { ids.add(n.image); }
      )*
    )?
    <ARROW> t1=Expression() <END>
    { t1 = new ASTFun(ids, t1); }
  |
    <LPAR> t1=Expression() <RPAR>
  )
  { return t1; }
}
